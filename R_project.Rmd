---
title: "R_project"
author: "Phillip An, Paul Park, Min Jin Kang"
date: "2023-04-05"
output: md_document
always_allow_html: true
---

```{r setup, include=FALSE}
library('TTR')
library('quantmod')
library('knitr')
library('xts')
library('lubridate')
library('vtable')
library('gridExtra')
library('grid')
library('pdp')
library('lattice')
library('tidyr')
library('ggthemes')
library('kableExtra')
library('scales')
library(corrplot)
library(ggplot2)
library(foreach)
library(tidyverse)
library(rpart)
library(rpart.plot)
library(dplyr)
library(rsample)  
library(caret)
library(modelr)
library(randomForest)
library(gbm)
library(pdp)
library(scales)
```

# Abstract

This paper is a study of which factors have a large impact on cryptocurrencies. Bitcoin and Ethereum were chosen as representative cryptocurrencies for our research, as these are two of the most popular and widely used with a significant market capitalization and user base. This study utilizes a random forest model to analyze the relationship between predictor variables and an outcome variable. Variable importance plots are used to identify the most significant predictor variables, and (meaningful conclusions) are drawn from the analysis.

# Introduction

Bitcoin, a type of digital currency run on blockchain technology, has recently gained traction as a potential currency to substitute for fiat money such as the U.S. dollar. A massive ‘money-printing’ by the Federal Reserve in response to the 2008 financial crisis and the Covid crisis has raised concerns about the strength and sustainability of the dollar value. Since then, market participants have been increasingly treating Bitcoin as a hedging asset. Devoid of the intrinsic value, however, Bitcoin has experienced a massive fluctuation in terms of asset prices. Specifically, at the onset of the Covid crisis in March 2020, the Bitcoin price dipped as low as `$5,165`. It grew more than tenfold to `$61,283` per Bitcoin in exactly one year, and hit as high as `$64,400` before crashing back down to hovering around `$25,000` in the beginning of the year 2023. Therefore, investors have taken interest in predicting the short-term Bitcoin price. → (too many have pp’s)

This report answers 3 questions. First, we attempt to test a variety of models and find a model that best predicts the Bitcoin price direction. We intend to look at the time horizons of 5-day, 10-day, and 20-day, representing 1 week, 2 weeks, and 4 weeks excluding weekends, respectively. Note that our report focuses on predicting the Bitcoin price direction, rather than the magnitude of the price. Predicting the size of the prices requires an exorbitant amount of computing power, and models often perform poorly. In other words, it is not cost-effective, nor efficient. We will show how accurate our model performs by comparing our model prediction and the realized price direction. 

Second, after identifying the best-predicting model, we attempt to find a variable that contributes the most to the price direction prediction. Next, we plan to run the model not only on Bitcoin but also on two other popular coins in terms of trading volumes, Ethereum, and Ripple, using common features. In doing so, we are able to find if these coins are ‘substitutes’ or ‘complements’ to one another. This finding can help investors make well-informed investment decisions; they may be able to diversify their digital asset portfolios in response to technical or macroeconomic shocks using our model. 

# Methods

## Data:

After reading a few existing studies regarding price prediction of an investment asset, we have learned that a wide spectrum of macroeconomic and market performance factors, such as inflation, interest rates, and market volatility are incorporated in building price predicting models. In addition to these common factors, we have also added some other variables we deemed important in terms of predictive power. Our data set consists of relevant daily asset prices, macroeconomic and market performance indicators, which are mainly collected from Yahoo Finance and Federal Reserve Economic Data (FRED).

First, we have daily prices of Bitcoin (BTC), Ethereum (ETH), oil, and gold. Inflation is measured by two proxies, yield on 10-year Treasury note (TNX) and 13 Week Treasury Bill (IRX). CBOE volatility index (VIX) estimates equity market volatility, while CBOE crude oil volatility index (OVX) measures oil market uncertainty. SP500, which tracks the top 500 U.S. stocks, is used to compute the US stock market performance. All of these data were collected from Yahoo Finance.

In addition to aforementioned inflation proxies, 5-Year breakeven inflation rate (inf5y), which implies market participants’ inflation expectation for the next five years, was also added. Equity Market Volatility: Infectious Disease Tracker (DISEASE) was included to account for the economic impact of COVID-19. U.S. dollar index (DXY) measures the performance of dollar against a basket of other world currencies. Policy-related uncertainty is measured by Economic Policy Uncertainty Index (EPU), and stock market uncertainty is measured by Equity Market Uncertainty Index (EMU). All of these data were collected from FRED. 

Lastly, we added Credit Default Swap (CDS), which basically is a financial derivative through which a seller can swap his credit risk with that of a buyer. As this indicator measures dwindling of centralized financial markets, we thought it would be interesting to see its relationship with the price action of cryptocurrencies, a decentralized asset class. This data was separately collected from Investing.com.


## Methodology:

In predicting Bitcoin price direction, we compare three main models: Classification and Regression Trees (CART), Random Forest and Gradient Boosting. To briefly recap what we learned in class, tree is a simple predictive model that is widely used in machine learning. CART, also called “recursive partitioning”, is a basic tree-fitting algorithm. Basically, we grow the tree recursively as to make deviance as small as possible. When we reach our minimum size or complexity stopping points, we will stop growing and prune back to make candidate trees. Lastly, we will choose via cross validation (min or 1SE).
 
Random forest is perhaps the most popular generic nonparametric regression technique as the model not only requires little to no cross validation and is also fast and effective. Here, we will fit trees to number of bootstrapped samples of the original data. This process, also called bagging, usually produces a better fit with lower variance than a single tree. It adds more randomness as we ‘randomly’ choose features subsets in building a tree, hence the name ‘random forest.’ After fitting a tree to each bootstrapped sample, we will average the predictions of all the different trees, producing an aggregated result, which should be more accurate.
 
Gradient boosting is an ensemble method like random forests. However, here you recursively fit simple trees to its ‘residuals’. That is, while random forests fits trees simultaneously, gradient boosting builds one tree at a time. This model adds the newly crushed tree into the fit in each stage along the way and so the final fit is the sum of many trees. Gradient boosting can work better than random forests with finely-tuned parameters. However, it is more sensitive to noise, thus more easily encounters over-fitting problems.

\newline
\newline

\newline
\newline

# Results

```{r price,message=FALSE, echo=FALSE, out.width="75%",out.height="50%", warning=FALSE}
# made from bitcoin_ether_price chunk with ggplot
knitr::include_graphics("Plots/price_compare.png")
```

```{r vol,message=FALSE, echo=FALSE, out.width="75%",out.height="50%", warning=FALSE}
# made from bitcoin_ether_volume below with ggplot
knitr::include_graphics("Plots/vol_compare.png")
```

```{r sum_stat,message=FALSE, echo=FALSE, out.width="50%",out.height="50%",warning=FALSE}
# made from bitcoin_ether_volume below with ggplot
knitr::include_graphics("Plots/Sumstat.png")
```

```{r get_yahoo_data,message=FALSE, echo=FALSE, warning=FALSE}

df_oil <- getSymbols('CL=F',src='yahoo',auto.assign=FALSE)
#nrow(df_oil) #4103
#head(df_oil,2) # 2007-01-03
#tail(df_oil,2) # 2023-04-04

df_gold <- getSymbols('GC=F',src='yahoo',auto.assign=FALSE)
#nrow(df_gold) #4103
#head(df_gold,2) # 2007-01-03
#tail(df_gold,2) # 2023-04-04

df_bitcoin <- getSymbols('BTC-USD',src='yahoo',auto.assign=FALSE)
#nrow(df_bitcoin) #3123
#head(df_bitcoin,2) # 2014-09-17
#tail(df_bitcoin,2) # 2023-04-05

df_ether <- getSymbols('ETH-USD',src='yahoo',auto.assign=FALSE)
#nrow(df_ether) #1980
#head(df_ether,2) # 2017-11-09
#tail(df_ether,2) # 2023-04-11

df_irx <- getSymbols('^IRX',src='yahoo',auto.assign=FALSE)
#nrow(df_irx) #4950
#head(df_irx,2) # 2007-01-03
#tail(df_irx,2) # 2023-04-04

df_tnx <- getSymbols('^TNX',src='yahoo',auto.assign=FALSE)
#nrow(df_tnx) #4950
#head(df_tnx,2) # 2007-01-03
#tail(df_tnx,2) # 2023-04-04

df_vix <- getSymbols('^VIX',src='yahoo',auto.assign=FALSE)
#nrow(df_vix) #4092
#head(df_vix,2) # 2007-01-03
#tail(df_vix,2) # 2023-04-04

df_ovx <- getSymbols('^OVX',src='yahoo',auto.assign=FALSE)
#nrow(df_ovx) #4004
#head(df_ovx,2) # 2007-05-01
#tail(df_ovx,2) # 2023-04-04

df_sp500 <- getSymbols('^GSPC',src='yahoo',auto.assign=FALSE)
#nrow(df_sp500) #4103
#head(df_sp500,2) # 2007-01-03
#tail(df_sp500,2) # 2023-04-04

```



```{r get_fred_data,message=FALSE, echo=FALSE, warning=FALSE}

df_dxy <- read.csv('Data/DXY.csv') # Nominal Broad U.S. Dollar Index
#nrow(df_dxy) #2417
#head(df_dxy) #2014-01-01
#tail(df_dxy) #2023-04-04

df_emu <- read.csv('Data/EMU.csv') # Equity Market-related Economic Uncertainty Index 
#nrow(df_emu) #3381
#head(df_emu) #2014-01-01
#tail(df_emu) #2023-04-04

df_epu <- read.csv('Data/EPU.csv') # Economic Policy Uncertainty Index for United States
#nrow(df_epu) #3381
#head(df_epu) #2014-01-01
#tail(df_epu) #2023-04-04

df_inf5y <- read.csv('Data/5YIE.csv') # 5-Year Breakeven Inflation Rate
#nrow(df_inf5y) #2414
#head(df_inf5y) #2014-01-01
#tail(df_inf5y) #2023-04-04

df_disease <- read.csv('Data/DISEASE.csv') # Equity Market Volatility: Infectious Disease Tracker
#nrow(df_disease) #3381
#head(df_disease) #2014-01-01
#tail(df_disease) #2023-04-04

df_cds <- read.csv('Data/1YCDS.csv') # United States CDS 1 Year USD
#nrow(df_cds) #1969
#head(df_cds) #2014-01-01
#tail(df_cds) #2023-04-04
df_cds=df_cds[1:2]
colnames(df_cds)[1] ="DATE"
df_cds$DATE <- as.Date(df_cds$DATE, "%m/%d/%Y")
df_cds$DATE <- format(df_cds$DATE, "%Y-%m-%d")

```



```{r merge_fred_data, message=FALSE, echo=FALSE, warning=FALSE, include=FALSE}
# change "chracter" date type to "date" date type
colnames(df_dxy)[1] ="DATE"
df_dxy$DATE <- ymd(df_dxy$DATE)
colnames(df_cds)[1] ="DATE"
df_cds$DATE <- ymd(df_cds$DATE)
colnames(df_emu)[1] ="DATE"
df_emu$DATE <- ymd(df_emu$DATE)
colnames(df_epu)[1] ="DATE"
df_epu$DATE <- ymd(df_epu$DATE)
colnames(df_inf5y)[1] ="DATE"
df_inf5y$DATE <- ymd(df_inf5y$DATE)
colnames(df_disease)[1] ="DATE"
df_disease$DATE <- ymd(df_disease$DATE)

colnames(df_dxy)[2] ="DXY"
colnames(df_cds)[2] ="CDS"
colnames(df_emu)[2] ="EMU"
colnames(df_epu)[2] ="EPU"
colnames(df_inf5y)[2] ="Inf5y"
colnames(df_disease)[2] ="Disease"

fred_0 <- merge(x=df_dxy, y=df_cds, by="DATE",all=TRUE)
fred_1 <- merge(x=df_emu, y=df_epu, by="DATE",all=TRUE)
fred_2 <- merge(x=df_inf5y, y=df_disease, by="DATE",all=TRUE)
fred_m <- merge(x=fred_0, y=fred_1, by="DATE",all=TRUE)
fred_data <- merge(x=fred_m, y=fred_2, by="DATE", all=TRUE)

# here, df_inf5y have some missing data
nrow(fred_data) #3384

# we can see some columns are character
sapply(fred_data, class)

# change character to numeric 
fred_data$DXY = as.numeric(as.character(fred_data$DXY)) 
fred_data$Inf5y = as.numeric(as.character(fred_data$Inf5y)) 
fred_data$Disease = as.numeric(as.character(fred_data$Disease)) 

# all numeric
sapply(fred_data, class)


```


```{r merge_yahoo_data, message=FALSE, echo=FALSE, warning=FALSE, include=FALSE}

# merge data
yahoo <- merge (df_oil,df_gold,df_bitcoin,df_ether,df_irx,df_tnx,df_vix,df_ovx,df_sp500)

# data has 2007-01-02 to 2023-04-05
head(yahoo)
tail(yahoo)

nrow(yahoo) #5481

# select data 2014-01-02 to 2023-04-05
yahoo_sliced_data = yahoo[2131:5468]

# all column is xts type 
sapply(yahoo_sliced_data, class)

# convert xts object to data.frame
data(yahoo_sliced_data)
x <- as.xts(yahoo_sliced_data, dateFormat="DATE")
yahoo_data <- fortify.zoo(x)
head(yahoo_data)
str(yahoo_data)

# change "Index" to "DATE"
colnames(yahoo_data)[1] ="DATE"
head(yahoo_data)

# check
str(yahoo_data)
sapply(yahoo_data, class)

# select only 'adjusted' data, dropping open/high/low/close/volume
cleaned_yahoo <- yahoo_data %>%
  select(DATE, CL.F.Adjusted, GC.F.Adjusted, BTC.USD.Adjusted, ETH.USD.Adjusted, IRX.Adjusted, TNX.Adjusted, VIX.Adjusted, OVX.Adjusted, GSPC.Adjusted)

colnames(cleaned_yahoo)
class(cleaned_yahoo$DATE)
```

```{r merge_two_data, message=FALSE, echo=FALSE, warning=FALSE, include=FALSE}

df <- merge(x=fred_data, y=cleaned_yahoo, by="DATE", all=TRUE)

# main dataset, containing everything including bitcoin and ether and all it's from 2014-01-01 to 2023-04-07
head(df)
tail(df)
colnames(df)
str(df)
nrow(df) #3384

df <- df %>%rename(Bitcoin = BTC.USD.Adjusted, Ethereum = ETH.USD.Adjusted, Oil=CL.F.Adjusted, Gold=GC.F.Adjusted, IRX=IRX.Adjusted, TNX=TNX.Adjusted, VIX=VIX.Adjusted, OVX=OVX.Adjusted, SP500=GSPC.Adjusted)

# adding 'Month' column from 'DATE' column
df$Month <- format(df$DATE, "%m")

# this month column is character class
# change character to numeric 
df$Month = as.numeric(as.character(df$Month)) 
```

```{r sumstat,message=FALSE, echo=FALSE, warning=FALSE, include=FALSE}
# making sumtable with sumtable()
sumtable(df)

```

## Bitcoin 

We used CART, Random Forest, and Gradient Boosted trees model and compared out-of-sample RMSEs, and we could check that the Random Forest is the best performance on the testing data.
\newline
`Bitcoin` is the target variable, and the rest of the variables, excluding the `DATE` variable, are used as predictors.
\newline
We used the randomForest function to fit a model and used the VarImpPlot function to display the variables which highly contribute to the model. 

```{r bitcoin_CART, message=FALSE, echo=FALSE, warning=FALSE, include=FALSE}

bitcoin <- df %>%
  select(DATE, Month, Bitcoin, Oil, Gold, IRX, TNX, VIX, OVX, SP500, DXY, CDS, EMU, EPU, Inf5y, Disease)


# drop na value. Main data set is from 2014-01-01 and bitcoin data is from 2014-09-17. Also weekend data will be dropped
bitcoin <- na.omit(bitcoin) 

# reset index
rownames(bitcoin) <- NULL

# this solves error(Error in eval(expr, envir, enclos) : object '' not found)
names(bitcoin) <- make.names(names(bitcoin))

nrow(bitcoin) #1723

# split training and testing set
bitcoin_split = initial_split(bitcoin, prop = 0.8)
bitcoin_train = training(bitcoin_split)
bitcoin_test = testing(bitcoin_split)

bitcoin_CART=rpart(Bitcoin ~ .-DATE, data=bitcoin_train, control=rpart.control(cp=0.002,minsplit=30))

# check the rmse
rmse_bitcoin_CART=rmse(bitcoin_CART,bitcoin_test)
```


### Random Forest

```{r bitcoin_RF, , message=FALSE, echo=FALSE, warning=FALSE}

bitcoin_RF=randomForest(Bitcoin ~ . -DATE, data=bitcoin_train,  important=TRUE)

# check the rmse
rmse_RF=rmse(bitcoin_RF,bitcoin_test)

varImpPlot(bitcoin_RF, bg = "skyblue", cex=1, pch=22)

```

We could check `SP500`,`Inf5y`,`Gold`,`IRX`,`Disease` are top 5 important variables for bitcoin. 

Below is the partial dependence plots to isolate the partial effect of specific features on the outcome. Partial dependence plot is a method used to analyze the relationship between the target variable (dependent variable) and a specific predictor variable while holding all other predictors constant.

```{r RF_dependence_plot, message=FALSE, echo=FALSE, warning=FALSE}
op <- par(mfrow=c(2, 3))
partialPlot(bitcoin_RF, bitcoin_test, 'SP500', las=1)
partialPlot(bitcoin_RF, bitcoin_test, 'Inf5y', las=1)
partialPlot(bitcoin_RF, bitcoin_test, 'Gold', las=1)
partialPlot(bitcoin_RF, bitcoin_test, 'IRX', las=1)
partialPlot(bitcoin_RF, bitcoin_test, 'Disease', las=1)
par(op, pin = c(10, 20))
```

All variables, except for `IRX`, shows an increasing dependence plot. We can interpret `SP500`, `Inf5y`,`Gold`,`Disease` features have a positive effect on predicted outcome, and `IRX` has a negative effect on predicted outcome. 

``` {r bitcoin_gradient, message=FALSE, echo=FALSE, warning=FALSE}
# fit a tree for gradient boosted trees
bitcoin_boost= gbm(Bitcoin ~ .-DATE ,distribution='gaussian', data=bitcoin_train,interaction.depth=4, n.trees=500, shrinkage=.05, cv.folds = 8)
# check the rmse
rmse_Boost=rmse(bitcoin_boost,bitcoin_test)

```


```{r RMSE_table, message=FALSE, echo=FALSE, warning=FALSE}
first_col= c("CART","Random Forest","Gradient Boosting")
second_col= c(rmse_bitcoin_CART,rmse_RF, rmse_Boost)
df_rmse_ = data.frame(first_col, second_col)
knitr::kable(df_rmse_,col.names = c("Model","RMSE"), caption="Model performance with out-of-sample RMSEs (Bitcoin)")%>% kable_minimal() %>% kable_styling(full_width = FALSE, position="left", latex_options="scale_down")

  

```


## Ethereum

Same as Bitcoin, to predict Ethereum, we used CART, Random Forest, and Gradient Boosted trees model and compared out-of-sample RMSEs, and we could check that the Random Forest is the best performance on the testing data.
\newline
`Ethereum` is the target variable, and the rest of the variables, excluding the `DATE` variable, are used as predictors.
\newline
We used the randomForest function to fit a model and used the VarImpPlot function to display the variables which highly contribute to the model.

```{r ethereum_CART, message=FALSE, echo=FALSE, warning=FALSE, include=FALSE}

ethereum <- df %>%
  select(DATE, Month, Ethereum, Oil, Gold, IRX, TNX, VIX, OVX, SP500, DXY, CDS, EMU, EPU, Inf5y, Disease)


# drop na value.
ethereum <- na.omit(ethereum) 

# reset index
rownames(ethereum) <- NULL

# this solves error(Error in eval(expr, envir, enclos) : object '' not found)
names(ethereum) <- make.names(names(ethereum))

nrow(ethereum) #1023

# split training and testing set
ethereum_split = initial_split(ethereum, prop = 0.8)
ethereum_train = training(ethereum_split)
ethereum_test = testing(ethereum_split)

ethereum_CART=rpart(Ethereum ~ .-DATE, data=ethereum_train, control=rpart.control(cp=0.002,minsplit=30))

# check the rmse
rmse_ethereum_CART=rmse(ethereum_CART,ethereum_test)
```



### Random Forest
```{r ethereum_RF, , message=FALSE, echo=FALSE, warning=FALSE}

ethereum_RF=randomForest(Ethereum ~ . -DATE, data=ethereum_train,  important=TRUE)

# check the rmse
rmse_RF=rmse(ethereum_RF,ethereum_test)

varImpPlot(ethereum_RF, bg = "skyblue", cex=1, pch=22)

```

We could check `SP500`,`Inf5y`,`Oil`,`IRX`,`CDS` are top 5 important variables for ethereum. `SP500` and `Inf5y` seem to have the highest importance in both bitcoin and ethereum, but it is an interesting result that there is a difference that gold has a great influence on bitcoin and oil has a great influence on ethereum.
\newline
Below is the partial dependence plots to isolate the partial effect of specific features on the outcome.

```{r RF_dependence_plot_ether, message=FALSE, echo=FALSE, warning=FALSE}
op_ether <- par(mfrow=c(2, 3))
partialPlot(ethereum_RF, ethereum_test, 'SP500', las=1)
partialPlot(ethereum_RF, ethereum_test, 'Inf5y', las=1)
partialPlot(ethereum_RF, ethereum_test, 'Oil', las=1)
partialPlot(ethereum_RF, ethereum_test, 'IRX', las=1)
partialPlot(ethereum_RF, ethereum_test, 'CDS', las=1)
par(op_ether,pin = c(10, 20))
```

All variables, except for `IRX`, shows an increasing dependence plot. We can interpret `SP500`, `Inf5y`,`Gold`,`Disease` features have a positive effect on predicted outcome, and `IRX` has a negative effect on predicted outcome. 

``` {r ethereum_gradient, message=FALSE, echo=FALSE, warning=FALSE}
# fit a tree for gradient boosted trees
ethereum_boost= gbm(Ethereum ~ .-DATE ,distribution='gaussian', data=ethereum_train,interaction.depth=4, n.trees=500, shrinkage=.05, cv.folds = 8)
# check the rmse
rmse_Boost=rmse(ethereum_boost,ethereum_test)

```


```{r RMSE_table_ether, message=FALSE, echo=FALSE, warning=FALSE}
first_col_= c("CART","Random Forest","Gradient Boosting")
second_col_= c(rmse_ethereum_CART,rmse_RF, rmse_Boost)
df_rmse__ = data.frame(first_col, second_col)
knitr::kable(df_rmse__,col.names = c("Model","RMSE"), caption="Model performance with out-of-sample RMSEs (Ethereum)")%>% kable_minimal() %>% kable_styling(full_width = FALSE, position="left", latex_options="scale_down")
  
  
```


```{r bitcoin_ether, message=FALSE, echo=FALSE, warning=FALSE, include=FALSE}
# select outcomes
compare <- df %>% select(DATE,Bitcoin,Ethereum)
# Bitcoin made first, drop na value for Bitcoin
compare <- compare %>% drop_na(Bitcoin)
# Fill na values existing in Ethereum
compare[is.na(compare)]<-0
view(compare)
```

```{r bitcoin_ether_price, message=FALSE, echo=FALSE, warning=FALSE, include=FALSE}
# Function factory for secondary axis transforms
train_sec <- function(primary, secondary, na.rm = TRUE) {
  from <- range(secondary, na.rm = na.rm)
  to   <- range(primary, na.rm = na.rm)
  # Forward transform for the data
  forward <- function(x) {
    rescale(x, from = from, to = to)
  }
  # Reverse transform for the secondary axis
  reverse <- function(x) {
    rescale(x, from = to, to = from)
  }
  list(fwd = forward, rev = reverse)
}

sec <- with(compare, train_sec(Bitcoin,Ethereum))


ggplot(compare, aes(x = DATE)) + 
  geom_line(aes(y = Bitcoin, color = "Bitcoin")) +
  geom_line(aes(y = sec$fwd(Ethereum), color = "Ethereum")) +
  scale_y_continuous(sec.axis = sec_axis(~sec$rev(.), name = "Ethereum"))+
  labs(title = "Bitcoin (BTC) and Ethereum (ETH) Price Comparison", x = "Date", y = "Price") +
  theme_economist_white(horizontal=FALSE, gray_bg=FALSE)


ggsave("Plots/price_compare.png", width = 10, height = 5, dpi = 300)


```

```{r bitcoin_ether_volume, message=FALSE, echo=FALSE, warning=FALSE, include=FALSE}
# select outcomes
compare_vol <- yahoo_data %>% select(DATE,BTC.USD.Volume,ETH.USD.Volume)
compare_vol <- compare_vol %>%rename(BTC_vol=BTC.USD.Volume,ETH_vol=ETH.USD.Volume)

# Bitcoin made first, drop na value for Bitcoin
compare_vol <- compare_vol %>% drop_na(BTC_vol)
# Fill na values existing in Ethereum
compare_vol[is.na(compare_vol)]<-0

ggplot(compare_vol, aes(x = DATE)) + 
  geom_line(aes(y = BTC_vol, color = "BTC_vol")) +
  geom_line(aes(y = ETH_vol, color = "ETH_vol")) +
  scale_y_continuous(limits = c(5, max(compare_vol$BTC_vol, compare_vol$ETH_vol, na.rm = TRUE) * 1.1)) +
  labs(title = "Bitcoin (BTC) and Ethereum (ETH) Volume Comparison", x = "Date", y = "Volume") +
  theme_economist_white(horizontal=FALSE, gray_bg=FALSE) 

ggsave("Plots/vol_compare.png", width = 10, height = 5, dpi = 300)

```



### Correlation Plots

For a deeper understanding of our paper, we will analyze the relationship with a correlation plot between predictors, which are macroeconomic and market performance factors. We know that correlation plot only measures the strength and direction of linear relationships between variables, but see correlation between predictors may provide some insights. 
\newline

Below is the correlation plot for every factors we added, you can check there's some stronger correlations, represented with darker colors. 

```{r corr,message=FALSE, echo=FALSE, warning=FALSE}

cluster_df <- df%>%select(Month, Oil, Gold, IRX, TNX, VIX, OVX, SP500, DXY, CDS, EMU, EPU, Inf5y, Disease)
cluster_df <- na.omit(cluster_df)
rownames(cluster_df) <- NULL

# center and scale
X=scale(cluster_df, center=TRUE, scale=TRUE)
# Extract the centers and scales from the rescaled data (which are named attributes)
mu = attr(X,"scaled:center")
sigma = attr(X,"scaled:scale")

corrplot::corrplot(cor(X), method='color', addCoef.col=0.4, number.cex = 0.4, tl.cex=0.7)

```

We decided to investigate the strong correlations with coefficients above 0.60. 
```{r corr_imp,message=FALSE, echo=FALSE, warning=FALSE}

corr_highest <- function(){
  corr = cor(X)
  # drop duplicates, and correlation 1
  corr[lower.tri(corr,diag=TRUE)] <- NA 
  corr[corr == 1] <- NA 
  # removing na values and making dataframe
  corr = as.data.frame(as.table(corr))
  corr = na.omit(corr) 
  # select significant values (more than 0.6)
  corr = subset(corr, abs(Freq) > 0.6) 
  # sort highest corr
  corr = corr[order(-abs(corr$Freq)),] 
  mtx_corr = reshape2::acast(corr, Var1~Var2, value.var="Freq")
  corrplot(mtx_corr, is.corr=FALSE, na.label=" ", tl.cex=0.7, col = colorRampPalette(c("#FFFFCC","#C7E9B4","#7FCDBB","#40B6C4","#2C7FB8" ,"#253494"))(100))
  knitr::kable(corr,row.names = FALSE, caption="Highest correlation among factors") %>% kable_minimal()
}
corr_highest()

```

Result shows `Gold` and `SP500` shows pretty strong correlation, 0.87. The next highest correlation is `VIX` and `Disease`.

(I think we should find some meaningful correlation here for our analysis)


## K-means clustering

We did supervised learning method, Random Forest. Now we will try an unsupervised learning, K-means clustering method, which can be used to identify clusters of similar factors. First, will start from choosing optimal K, the amount of clusters. Below is Elbow plot. Elbow plot used to determine the optimal number of clustering. The plot displays within-cluster sum of squares(WSS) as a function of the number of clusters.

```{r cluster, message=FALSE, echo=FALSE, warning=FALSE}

# use the code we learned during the class
k_grid = seq(2, 30, by=1)
SSE_grid = foreach(k = k_grid, .combine='c') %do% {
  cluster_k = kmeans(X, k, nstart=25)
  cluster_k$tot.withinss
}
# plotting elbow plot to see 
plot(k_grid, SSE_grid, main="Elbow Plot") 

```

Will use 6 for k, the number of clusters. 

```{r kcluster, message=FALSE, echo=FALSE, warning=FALSE, including=FALSE}
# Run k-means with 6 clusters and 25 starts
clu= kmeans(X, centers=6, nstart=25)
# make an empty list to store kable output
kable_output <- list()
# loop through each plot and sort by the first column in ascending order, then print the top 5 rows
for (i in 0:5) {
  plot_name <- paste0("cluster", i+1)
  plot <- data.frame(clu$center[i+1,]*sigma + mu)
  plot_sorted_top5 <- plot %>% arrange(desc(plot[1])) %>% head(5)
  names(plot_sorted_top5)[1] <- plot_name
  kable_output[[i+1]] <- plot_sorted_top5
}
# print the kable output for all 10 plots
knitr::kable(kable_output)%>% kable_minimal() %>% kable_styling(full_width = FALSE, position="left", latex_options="scale_down")
```





# Conclusion


# Appendix
```{r timeseries_tables, message=FALSE, echo=FALSE, warning=FALSE, include=FALSE}

chartSeries(df_oil,name="Crude Oil",theme = 'white',subset='2014::2023')
chartSeries(df_gold,name="Gold",theme = 'white',subset='2014::2023')
chartSeries(df_bitcoin,name="Bitcoin",theme = 'white',subset='2014::2023')
chartSeries(df_ether,name="Ethereum",theme = 'white',subset='2017::2023')
plot(df_irx, main = '13 Week Treasury Bill')
plot(df_tnx, main = 'Treasury Yield 10 Years')
plot(df_vix, main="CBOE Volatility Index")
plot(df_ovx,name="CBOE Crude Oil Volatility Index")
chartSeries(df_sp500,name="S&P 500",theme = 'white',subset='2014::2023')

asset_comp <- read.csv('Data/asset_market_cap.csv') # comparison of market cap of diff asset classes

ggplot(asset_comp, aes(x = Name, y = Market_Cap)) +
  geom_col() +
  coord_flip()



```